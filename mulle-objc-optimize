#! /usr/bin/env mulle-bash
#
# this script accepts a file of coverage info
# each line is matches against the .csv output from
# mulle-objc-unarchive, the corresponding .o file
# is then printed-
#
# You then get a library obcj.a, that is linked wholesale
# and a library c.a that is linked normally, so that the
# linker only cherrypicks required symbols.
#

MULLE_EXECUTABLE_VERSION=0.9.1

MULLE_EXECUTABLE_FUNCTIONS_MIN="3.9"
MULLE_EXECUTABLE_FUNCTIONS_MAX="4"



usage()
{
   cat <<EOF >&2
Usage:
   ${MULLE_USAGE_NAME} [options] <library>+

   This program will generate two static libraries from the output of
   mulle-objc-unarchive. One can be linked as C code (size reduction possible)
   and one needs to be linked as Objective-C code (no size reduction possible).
   The decision into which library code is moved, is based on coverage info
   you get from running an executable with the environment variable
   MULLE_OBJC_COVERAGE.

Options:
EOF
   (
      options_technical_flags_usage "                  : "

      cat <<EOF
   --c-name <name>        : C library name
   --cflags               : CFLAGS for loader recompilation
   --coverage-dir <dir>   : location of the coverage files
   --cppflags             : CPPFLAGS for loader recompilation
   --dependency-dir <dir> : The dependency directory of your project
   --keep-tmp             : do not erase temporarily created files
   --library-dir <dir>    : destination for the output libraries
   --objc-name <name>     : ObjC library name
   --optimize-dir <dir>   : location of intermediate folders
   --prefix <dir>         : prefix for output libraries
   --strip-loads          : ignore +load calls in coverage (dangerous)
   --tmp-dir <dir>        : override TMPDIR
   --unarchive-dir <dir>  : location of the folders generated by mulle-objc-unarchive
EOF
   ) | sort >&2

   echo >&2

   exit 1
}


r_name_from_library()
{
   log_entry "r_name_from_library" "$@"

   local library="$1"

   # remove extension
   r_extensionless_basename "${library}"
   library="${RVAL}"

   # remove prefix
   case "${library}" in
      lib*)
         RVAL="`sed 's/^lib//' <<< "${library}"`"
      ;;
   esac

   case "${library}" in
      *Standalone)
         RVAL="`sed 's/Standalone$//' <<< "${library}"`"
      ;;
   esac
}


r_foldername_from_library()
{
   log_entry "r_foldername_from_library" "$@"

   local library="$1"
   local prefix="$2"

   r_name_from_library "${library}"
   RVAL="${prefix}${RVAL}.d"
}


optionally_strip_class_load_from_methods()
{
   log_entry "optionally_strip_class_load_from_methods" "$@"

   if [ "${OPTION_STRIP_LOAD}" = "YES" ]
   then
      rexekutor egrep -v ';60759e9e;\+load$'
   else
      rexekutor cat
   fi
}


strip_class_dependencies_from_methods()
{
   log_entry "strip_class_dependencies_from_methods" "$@"

   rexekutor egrep -v ';53d9d606;\+dependencies$'
}


strip_class_superclass()
{
   log_entry "strip_class_superclass" "$@"

   rexekutor cut -d';' -f1-2
}


strip_used_class_superclass()
{
   log_entry "strip_used_class_superclass" "$@"

   rexekutor cut -d';' -f'1-2,5'
}


create_empty_library()
{
   log_entry "create_empty_library" "$@"

   local library="$1"
   local name="$2"

   log_fluff "Create empty library \"${library}\""

   while :
   do
      r_make_tmp_file "unused"
      ofile="${RVAL}"

      if exekutor mv "${ofile}" "${ofile}.o"
      then
         ofile="${ofile}.o"
         break
      fi
      remove_file_if_present "${ofile}"
   done

   rexekutor echo "void   __unused_linkage_${name}( void) {}" | \
       exekutor "${CC}" -x c -o "${ofile}" -c - &&

   exekutor ar ${ARFLAGS} "${library}" "${ofile}" || return 1

   remove_file_if_present "${ofile}"
}

#
# remove loader +dependencies from coverage (and optionally and risky +loads)
# also trim down coverage file by sort -u, in case multiple coverage files
# have been concatenated
#
prepare_coverage_files()
{
   log_entry "prepare_coverage_files" "$@"

   [ ! -d "${OPTIMIZE_INFO_DIR}" ] && _internal_fail "OPTIMIZE_INFO_DIR \"${OPTIMIZE_INFO_DIR}\" is missing"

   if [ ! -f "${COVERAGE_PREFIX}method-coverage.csv" ]
   then
      fail "Coverage file ${COVERAGE_PREFIX}method-coverage.csv not found"
   fi

   if [ ! -f "${COVERAGE_PREFIX}class-coverage.csv" ]
   then
      fail "Coverage file ${COVERAGE_PREFIX}class-coverage.csv not found"
   fi

   redirect_exekutor "${OPTIMIZE_INFO_DIR}/method-coverage.csv" \
      sort -u "${COVERAGE_PREFIX}method-coverage.csv" \
      | strip_class_dependencies_from_methods  \
      | optionally_strip_class_load_from_methods \

   redirect_exekutor "${OPTIMIZE_INFO_DIR}/class-coverage.csv" \
      sort -u "${COVERAGE_PREFIX}class-coverage.csv" \
      | strip_class_superclass

   return 0
}

create_category_objc_loader()
{
   local file="$1"

   local class_h class_n category_h category_n method_h method_n ofile

   while IFS=';' read -r class_h class_n category_h category_n method_h method_n ofile
   do
      if [ -z "${category_h}" ]
      then
         continue
      fi
      [ -z "${category_n}" ] && _internal_fail "internal inconsistency"

      printf "      { @selector( %s ), @selector( %s) },      // %s;%s;%s;%s\n" \
                  "${class_n}" "${category_n}" \
                  "${class_n}" "${class_h}" "${category_h}" "${category_n}"
   done < "${file}" | sort -u
}


create_class_objc_loader()
{
   local file="$1"

   rexekutor sed -e 's/^\([^;]*\);\([^;]*\);.*$/      { @selector( \2), MULLE_OBJC_NO_CATEGORYID },      \/\/ \1;\2;;/' \
      "${file}"
}


create_all_files()
{
   local folder="$1"

   (
      rexekutor cd "${folder}" && rexekutor ls -1 *.o
   )
}


_optimize_folder()
{
   log_entry "_optimize_folder" "$@"

   local opti="$1"
   local opti_info="$2"
   local name="$3"
   local folder="$4"

   shift 4

   log_fluff "Optimize \"${folder}\" in \"${opti#${MULLE_USER_PWD}/}\" and \"${opti_info#${MULLE_USER_PWD}/}\""

   log_setting "opti      : ${opti}"
   log_setting "opti_info : ${opti_info}"
   log_setting "name      : ${name}"
   log_setting "folder    : ${folder}"

   #
   # collect all object files
   # if this directory can be optimized, then there are no loaders present
   # if this directory is c-only, we take everything anyway
   # if this directory can not be optimized, there may be loaders though
   # which will be taken care of later
   #

   rexekutor [ ! -f "${folder}/.unpack_done" ] && \
      fail "\"${folder}\" was unpacked incompletely by mulle-objc-unarchive"

   if [ "${OPTION_REUSE_INFO_DIR}" != 'YES' ]
   then
      local text

      text="`create_all_files "${folder}" `" || exit 1

      redirect_exekutor "${opti_info}/all_files" printf "%s\n" "${text}"
   fi

   if rexekutor [ -f "${folder}/.c_only" ]
   then
      log_verbose "${C_MAGENTA}${C_BOLD}${name}${C_VERBOSE} is C"

      r_escaped_sed_replacement "${folder}/"
      exekutor sed -e "s/^/${RVAL}/" "${opti_info}/all_files" \
      | tr '\010' '\000' \
      | exekutor xargs ar ${ARFLAGS} "${C_LIBRARY}" || \
           fail "Could not add to \"${C_LIBRARY}\""
      return 0
   fi

   #
   # in the non-optimizable case, just add all .o files
   # make sure that loaders are last
   #
   local optimizable

   if rexekutor [ ! -f "${folder}/.unoptimizable" ]
   then
      optimizable='YES'

      log_verbose "${C_MAGENTA}${C_BOLD}${name}${C_VERBOSE} is ObjC"

      [ ! -f "${folder}/.unarchive_done" ] && \
         fail "\"${folder}\" was unarchived incompletely by mulle-objc-unarchive (${folder}/.unarchive_done is missing)"

      if [ "${OPTION_REUSE_INFO_DIR}" != 'YES' ]
      then
         [ ! -f "${OPTIMIZE_INFO_DIR}/method-coverage.csv" ] && _internal_fail "\"${OPTIMIZE_INFO_DIR}/method-coverage.csv\" is missing"
         [ ! -f "${OPTIMIZE_INFO_DIR}/class-coverage.csv" ]  && _internal_fail "\"${OPTIMIZE_INFO_DIR}/class-coverage.csv\" is missing"

         [ ! -f "${folder}/method_db.csv" ] && _internal_fail "\"${folder}/method_db.csv\" is missing"
         [ ! -f "${folder}/class_db.csv" ]  && _internal_fail "\"${folder}/class_db.csv\" is missing"

         [ ! -f "${opti_info}/all_files" ]  && _internal_fail "\"${opti_info}/all_files\" is missing"

         log_debug "Create objc_files"

         # get actually used methods in classes from coverage
         # coverage has been cleaned off +dependencies
         #
         redirect_exekutor "${opti_info}/used_method_db.csv" \
            grep -F -f "${OPTIMIZE_INFO_DIR}/method-coverage.csv" "${folder}/method_db.csv"

         #
         # need to groom class_db.csv
         #
         redirect_exekutor "${opti_info}/class_db.csv" \
            strip_used_class_superclass < "${folder}/class_db.csv"

         redirect_exekutor "${opti_info}/used_class_db.csv" \
            grep -F -f "${OPTIMIZE_INFO_DIR}/class-coverage.csv" "${opti_info}/class_db.csv"

         # collect object files containing used methods and classes
         (
            rexekutor awk -F ';' '{ print $7 }' "${opti_info}/used_method_db.csv"
            rexekutor awk -F ';' '{ print $5 }' "${opti_info}/used_class_db.csv"
         ) | redirect_exekutor "${opti_info}/objc_files" sort -u

         #
         # figure out remaining files
         # fgrep doesn't match empty files well though
         #
         if [ ! -z "`head -1 "${opti_info}/objc_files"`" ]
         then
            redirect_exekutor "${opti_info}/c_files" \
                grep -F -x -v -f "${opti_info}/objc_files" "${opti_info}/all_files"
         else
            exekutor cp "${opti_info}/all_files" "${opti_info}/c_files"
         fi

         if [ "${MULLE_FLAG_LOG_VERBOSE:-}" = 'YES' ]
         then
            local optimized
            local all

            optimized="`exekutor wc -l "${opti_info}/c_files" | awk '{ print $1 }'`" || _internal_fail "fail"
            all="`exekutor wc -l "${opti_info}/all_files" | awk '{ print $1 }'`" || _internal_fail "fail"

            log_verbose "${optimized} of ${all} files can be optimized away"
         fi
      fi
   else
      optimizable="NO"

      log_verbose "${C_MAGENTA}${C_BOLD}${name}${C_VERBOSE} is unoptimizable ObjC"

      if [ "${OPTION_REUSE_INFO_DIR}" != 'YES' ]
      then
         redirect_exekutor "${opti_info}/objc_files" \
            grep -E -v "^MulleObjCLoader" "${opti_info}/all_files"

         (
            rexekutor cd "${folder}" &&
            redirect_append_exekutor "${opti_info}/objc_files" \
               ls -1 MulleObjCLoader*.o
         )
      fi
   fi


   local has_objects


   #
   # add files to the libraries already
   # doesn't work with spaces in filenames though...
   #
   has_objects="`exekutor head -1 "${opti_info}/objc_files" 2> /dev/null`"
   if [ ! -z "${has_objects}" ]
   then
      log_fluff "Adding unoptimizable files of \"${name}\" to \"${OBJC_LIBRARY}\"..."
      r_escaped_sed_replacement "${folder}/"
      exekutor sed -e "s/^/${RVAL}/" "${opti_info}/objc_files" \
      | tr '\010' '\000' \
      | exekutor xargs ar ${ARFLAGS} "${OBJC_LIBRARY}" || \
         fail "Could not add to \"${OBJC_LIBRARY}\""
   fi

   #
   # if library is unoptimizable we are done now
   #
   if [ "${optimizable}" = 'NO' ]
   then
      log_fluff "As \"${name}\" is unoptimizable, we are done here"
      if [ "${OPTION_REUSE_INFO_DIR}" != 'YES' ]
      then
         redirect_exekutor "${opti_info}/class-objc-loader.inc" \
            echo "// not optimizable"
         redirect_exekutor "${opti_info}/category-objc-loader.inc" \
            echo "// not optimizable"
      fi
      return 0
   fi

   local has_c_files

   has_c_files="`exekutor head -2 "${opti_info}/c_files" 2> /dev/null`"
   if [ ! -z "${has_c_files}" ]
   then
      log_fluff "Adding optimizable files of \"${name}\" to \"${C_LIBRARY}\"..."
      r_escaped_sed_replacement "${folder}/"
      exekutor sed -e "s/^/${RVAL}/" "${opti_info}/c_files" \
      | tr '\010' '\000' \
      | exekutor xargs ar ${ARFLAGS} "${C_LIBRARY}" || \
         fail "Could not add to \"${OBJC_LIBRARY}\""
   fi

   #
   # now re-build the loader for non optimizable
   # use ${opti_info}/used_method_db.csv and "${opti_info}/used_class_db.csv"
   #
   loadername="MulleObjCLoader+${name}"
   srcfile="${folder}/${loadername}.m"
   ofile="${opti}/${loadername}.m.o"  # cmake compatible

   log_fluff "Rebuilding the loader \"${ofile}\"..."

   if [ "${OPTION_REUSE_INFO_DIR}" != 'YES' ]
   then
      redirect_exekutor "${opti_info}/class-objc-loader.inc" \
         create_class_objc_loader "${opti_info}/used_class_db.csv"

      redirect_exekutor "${opti_info}/category-objc-loader.inc"  \
         create_category_objc_loader "${opti_info}/used_method_db.csv"
   fi

   exekutor [ ! -f "${srcfile}" ] && _internal_fail "\"${srcfile}\" is missing"

   eval_exekutor mulle-clang -c \
                             -o "'${ofile}'" \
                             "${CPPFLAGS}" \
                             "${CFLAGS}" \
                             -I"'${opti_info}'" \
                             "'${srcfile}'" || fail "Failed to recompile the loader"

   log_fluff "Adding the loader of \"${name}\" to \"${OBJC_LIBRARY}\"..."

   exekutor ar ${ARFLAGS} "${OBJC_LIBRARY}" "${ofile}" || fail "Could not add to \"${OBJC_LIBRARY}\""
}


optimize_folder()
{
   log_debug "optimize_folder" "$*"

   local folder="$1"

   shift

   local opti
   local opti_info
   local directoryname
   local name

   r_basename "${folder}"
   directoryname="${RVAL}"

   name="${directoryname%.d}"
   opti="${OPTIMIZE_DIR}/${directoryname}"
   opti_info="${OPTIMIZE_INFO_DIR}/${directoryname}"

   if [ ! -f "${folder}/.unpack_done" ]
   then
      log_warning "Ignoring stray folder \"${folder}\""
      return 1
   fi

   if [ "${OPTION_REUSE_INFO_DIR}" = 'DEFAULT' ]
   then
      if [ -f "${opti_info}/.optimize_done" ]
      then
         OPTION_REUSE_INFO_DIR='YES'
      fi
   fi

   if [ "${OPTION_REUSE_INFO_DIR}" = 'YES' ]
   then
      if [ ! -f "${opti_info}/.optimize_done" ]
      then
         fail "Reusable optimization info folder \"${opti_info}\" is incomplete. Remove and retry."
      fi
   else
      mkdir_if_missing "${opti_info}"
   fi
   mkdir_if_missing "${opti}"


   if _optimize_folder "${opti}" "${opti_info}" "${name}" "${folder}" "$@"
   then
      exekutor touch "${opti_info}/.optimize_done"
   fi
}


optimize()
{
   log_debug "optimize" "$*"

   local folder
   local anything

   prepare_coverage_files

   anything="NO"
   if [ $# -eq 0 ]
   then
      IFS=$'\n'
      for folder in `ls -1d ${UNARCHIVE_PREFIX}*.d 2> /dev/null`
      do
         IFS="${DEFAULT_IFS}"

         if optimize_folder "${folder}"
         then
            anything='YES'
         fi
      done
      IFS="${DEFAULT_IFS}"
   else
      while [ $# -ne 0 ]
      do
         r_foldername_from_library "$1" "${UNARCHIVE_PREFIX}"
         folder="${RVAL}"

         if optimize_folder "${folder}"
         then
            anything='YES'
         fi
         shift
      done
   fi

   if [ "${anything}" = "NO" ]
   then
      if [ -z "${UNARCHIVE_PREFIX}" ]
      then
         fail "There was nothing found to optimize!"
      else
         fail "There was nothing found to optimize in \"${UNARCHIVE_PREFIX}\""
      fi
   fi

   if [ -f "${OBJC_LIBRARY}" ]
   then
      exekutor ranlib "${OBJC_LIBRARY}"
      log_verbose "Produced \"${OBJC_LIBRARY}\" for Objective-C link (-all_load)"
   else
      log_warning "All Objective-C code optimized away. That's probably not good!!"
      create_empty_library "${OBJC_LIBRARY}" "objc"
   fi

   if [ -f "${C_LIBRARY}" ]
   then
      exekutor ranlib "${C_LIBRARY}"
      log_verbose "Produced \"${C_LIBRARY}\" for standard link"
   else
      log_info "No optimizable Objective-C code found!"
      create_empty_library "${C_LIBRARY}" "c"
   fi
}


main()
{
   local OPTION_CLEANUP_TMP="" # empty
   local OPTION_REUSE_INFO_DIR='DEFAULT'

   local OBJC_LIBRARY
   local C_LIBRARY
   local PREFIX
   local C_NAME
   local OBJC_NAME
   local CLEANUP
   local C_DEFAULT_NAME=C
   local OBJC_DEFAULT_NAME=ObjC
   local LIBRARY_DIR

   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      # your option handling
      case "$1" in
         -h|--help|help)
            usage
         ;;

         --c-name)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            C_NAME="$1"
         ;;

         --cppflags)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            CPPFLAGS="$1"
         ;;

         --cflags)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            CFLAGS="$1"
         ;;

         --coverage-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            COVERAGE_PREFIX="$1"
            case "${COVERAGE_PREFIX}" in
               */|"")
               ;;

               *)
                  COVERAGE_PREFIX="${COVERAGE_PREFIX}/"
               ;;
            esac
         ;;

         --dependency-dir|--dependencies-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            DEPENDENCY_DIR="$1"
         ;;

         --include-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            INCLUDE_DIR="$1"
         ;;

         --keep-tmp)
            OPTION_CLEANUP_TMP="NO"
         ;;

         --library-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            LIBRARY_DIR="$1"
         ;;

         --objc-name)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            OBJC_NAME="$1"
         ;;

         --optimize-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            OPTIMIZE_DIR="$1"
         ;;

         --optimize-info-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            OPTIMIZE_INFO_DIR="$1"
         ;;

         --prefix)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            PREFIX="$1"
         ;;

         --reuse-info-dir)
            OPTION_REUSE_INFO_DIR="YES"
         ;;

         --no-reuse-info-dir)
            OPTION_REUSE_INFO_DIR="NO"
         ;;

         --strip-loads)
            OPTION_STRIP_LOAD="YES"
         ;;

         --unarchive-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            UNARCHIVE_PREFIX="$1"
            case "${UNARCHIVE_PREFIX}" in
               */|"")
               ;;

               *)
                  UNARCHIVE_PREFIX="${UNARCHIVE_PREFIX}/"
               ;;
            esac
         ;;

         --version)
            echo "${MULLE_EXECUTABLE_VERSION}"
            exit 0
         ;;

         -*)
            fail "unknown option $1"
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE}" && set -x

   if [ -z "${MULLE_VIRTUAL_ROOT}" ]
   then
      MULLE_VIRTUAL_ROOT="`mulle-sde project-dir`"
      [ -z "${MULLE_VIRTUAL_ROOT}" ] && fail "MULLE_VIRTUAL_ROOT can not be determined"
   fi

   DEPENDENCY_DIR="${DEPENDENCY_DIR:-`mulle-sde dependency-dir`}"
   DEPENDENCY_DIR="${DEPENDENCY_DIR:-"${MULLE_VIRTUAL_ROOT}/dependency"}"

   LIBRARY_DIR="${LIBRARY_DIR:-${DEPENDENCY_DIR}/lib}"

   local MULLE_PLATFORM_FRAMEWORK_PATH_LDFLAG
   local MULLE_PLATFORM_FRAMEWORK_PREFIX
   local MULLE_PLATFORM_FRAMEWORK_SUFFIX
   local MULLE_PLATFORM_LIBRARY_LDFLAG
   local MULLE_PLATFORM_LIBRARY_PATH_LDFLAG
   local MULLE_PLATFORM_LIBRARY_PREFIX
   local MULLE_PLATFORM_LIBRARY_SUFFIX_STATIC
   local MULLE_PLATFORM_LIBRARY_SUFFIX_DYNAMIC
   local MULLE_PLATFORM_LINK_MODE
   local MULLE_PLATFORM_RPATH_LDFLAG
   local MULLE_PLATFORM_WHOLE_ARCHIVE_LDFLAG_DEFAULT
   local MULLE_PLATFORM_WHOLE_ARCHIVE_LDFLAG_STATIC

   eval `rexekutor mulle-platform environment`

   C_DEFAULT_NAME="${MULLE_PLATFORM_LIBRARY_PREFIX}_c${MULLE_PLATFORM_LIBRARY_SUFFIX_STATIC}"
   OBJC_DEFAULT_NAME="${MULLE_PLATFORM_LIBRARY_PREFIX}_ObjC${MULLE_PLATFORM_LIBRARY_SUFFIX_STATIC}"

   if [ -z "${CC}" ]
   then
      case "${MULLE_UNAME}" in
         mingw*)
            CC="mulle-clang-cl"
         ;;

         *)
            CC="mulle-clang"
         ;;
      esac
   fi

   if [ -z "${CPPFLAGS}" ]
   then
      case "${MULLE_UNAME}" in
         darwin)
            CPPFLAGS="-isysroot "'`xcrun --show-sdk-path`'""
         ;;
      esac

      if [ ! -z "${INCLUDE_DIR}" ]
      then
         r_concat "${CPPFLAGS}" "-isystem '${INCLUDE_DIR}'"
         CPPFLAGS="${RVAL}"
      else
         local includes
         local include

         includes="`find "${DEPENDENCY_DIR}" -name include -type d -print`"
         .foreachline include in ${includes}
         .do
            r_escaped_singlequotes "${include}"
            r_concat "${CPPFLAGS}" "-isystem '${RVAL}'"
            CPPFLAGS="${RVAL}"
         .done
      fi
   fi

   local ARFLAGS

   case "${MULLE_UNAME}" in
      darwin)
         ARFLAGS="-q -c -S"
      ;;

      *)
         ARFLAGS="rs"
      ;;
   esac


   r_filepath_concat "${PREFIX}" "${OBJC_NAME:-${OBJC_DEFAULT_NAME}}"
   OBJC_LIBRARY="${RVAL}"

   r_filepath_concat "${PREFIX}" "${C_NAME:-${C_DEFAULT_NAME}}"
   C_LIBRARY="${RVAL}"

   [ -z "${C_LIBRARY}" ] && _internal_fail "C library name is empty"
   [ -z "${OBJC_LIBRARY}" ] && _internal_fail "ObjC library name is empty"
   [ "${C_LIBRARY}" = "${OBJC_LIBRARY}" ] && _internal_fail "ObjC library and C library share name"

   remove_file_if_present "${OBJC_LIBRARY}"
   remove_file_if_present "${C_LIBRARY}"

   r_mkdir_parent_if_missing "${OBJC_LIBRARY}"
   # ignore RVAL

   local tmpdir

   if [ -z "${OPTIMIZE_DIR}" -o  -z "${OPTIMIZE_INFO_DIR}"  ]
   then
      r_make_tmp_directory "optimize"
      tmpdir="${RVAL}"
   fi

   if [ -z "${OPTIMIZE_DIR}" ]
   then
      OPTIMIZE_DIR="${tmpdir}/optimize"
      log_fluff "OPTIMIZE_DIR is ${OPTIMIZE_DIR}"
   fi

   mkdir_if_missing "${OPTIMIZE_DIR}"

   # can share with OPTIMIZE_DIR (old configuration)
   OPTIMIZE_INFO_DIR="${OPTIMIZE_INFO_DIR:-${OPTIMIZE_DIR}}"

   mkdir_if_missing "${OPTIMIZE_INFO_DIR}"

   log_info "Optimize libraries"
   optimize "$@"

   if [ ! -z "${tmpdir}" -a "${OPTION_CLEANUP_TMP}" = 'NO' ]
   then
      log_info "Clean up"
      exekutor rm -rf "${tmpdir}"
   fi
   log_info "Done"
}

main "$@"
