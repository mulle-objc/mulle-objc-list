#! /usr/bin/env bash
#
# this script accepts a file of coverage info
# each line is matches against the .csv output from
# mulle-objc-unarchive, the corresponding .o file
# is then printed-
#
# You then get a library obcj.a, that is linked wholesale
# and a library c.a that is linked normally, so that the
# linker only cherrypicks required symbols.
#

MULLE_EXECUTABLE_VERSION=0.9.1

MULLE_EXECUTABLE_FUNCTIONS_MIN="3.9"
MULLE_EXECUTABLE_FUNCTIONS_MAX="4"


usage()
{
   cat <<EOF >&2
Usage:
   ${MULLE_EXECUTABLE} [options] <library>+

   This program will generate two static libraries from the output of
   mulle-objc-unarchive. One can be linked like C code (size reduction possible)
   and one needs to linked like Objective-C code (no size reduction possible).
   The decision into which library code is moved, is based on coverage info
   you get from running an executable with the environment variable
   MULLE_OBJC_COVERAGE.

Options:
EOF
   (
      options_technical_flags_usage

      cat <<EOF

   --c-name <name>          : C library name (instead of ${C_DEFAULT_NAME})
   --cflags                 : CFLAGS for loader recompilation
   --coverage-dir <dir>     : location of the coverage files
   --cppflags               : CPPFLAGS for loader recompilation
   --dependency-dir <dir>   : The dependency directory of your project
   --keep-tmp               : do not erase temporarily created files
   --library-dir <dir>      : destination for the output libraries
   --objc-name <name>       : ObjC library name (instead of ${OBJC_DEFAULT_NAME})
   --optimize-dir <dir>     : location intermediate folders
   --strip-loads            : ignore +load calls in coverage (dangerous)
   --tmp-dir <dir>          : override TMPDIR
   --unarchive-dir <dir>    : location of the folders generated by mulle-objc-unarchive
EOF
   ) | sort >&2

   exit 1
}



# ahem
lib_pretension()
{
   case "${MULLE_UNAME}" in
      mingw*)
      ;;

      *)
         echo "lib"
       ;;
   esac
}


lib_extension()
{
   case "${MULLE_UNAME}" in
      mingw*)
         echo "lib"
      ;;

      *)
         echo "a"
       ;;
   esac
}


name_from_library()
{
   log_entry "name_from_library" "$@"

   local library="$1"

   # remove extension
   library="`extensionless_basename "${library}"`"

   # remove prefix
   case "${library}" in
      lib*)
         library="`LC_ALL=C sed 's/^lib//' <<< "${library}"`"
      ;;
   esac

   case "${library}" in
      *Standalone)
         library="`LC_ALL=C sed 's/Standalone$//' <<< "${library}"`"
      ;;
   esac

   echo "${library}"
}


foldername_from_library()
{
   log_entry "foldername_from_library" "$@"

   local library="$1"
   local prefix="$2"

   local name

   name="`name_from_library "${library}"`"
   echo "${prefix}${name}.d"
}


optionally_strip_class_load_from_methods()
{
   log_entry "optionally_strip_class_load_from_methods" "$@"

   if [ "${OPTION_STRIP_LOAD}" = "YES" ]
   then
      rexekutor egrep -v ';1f2fdaed;\+load$'
   else
      rexekutor cat
   fi
}


strip_class_dependencies_from_methods()
{
   log_entry "strip_class_dependencies_from_methods" "$@"

   rexekutor egrep -v ';fb10562e;\+dependencies$'
}


create_empty_library()
{
   log_entry "create_empty_library" "$@"

   local library="$1"
   local name="$2"

   log_fluff "Create empty library \"${library}\""

   while :
   do
      ofile="`make_tmp_file "unused"`"
      if exekutor mv "${ofile}" "${ofile}.o"
      then
         ofile="${ofile}.o"
         break
      fi
      remove_file_if_present "${ofile}"
   done

   rexekutor echo "void   __unused_linkage_${name}( void) {}" | \
       exekutor "${CC}" -x c -o "${ofile}" -c - &&

   exekutor ar -r -c "${library}" "${ofile}" || return 1

   remove_file_if_present "${ofile}"
}

#
# remove loader +dependencies from coverage (and optionally and risky +loads)
# also trim down coverage file by sort -u, in case multiple coverage files
# have been concatenated
#
prepare_coverage_files()
{
   log_entry "prepare_coverage_files" "$@"

   TMPDIR="${TMPDIR:-/tmp}"

   [ ! -d "${TMPDIR}" ] && internal_fail "TMPDIR \"${TMPDIR}\" is missing"

   if [ ! -f "${COVERAGE_PREFIX}method-coverage.csv" ]
   then
      fail "Coverage file ${COVERAGE_PREFIX}method-coverage.csv not found"
   fi

   if [ ! -f "${COVERAGE_PREFIX}class-coverage.csv" ]
   then
      fail "Coverage file ${COVERAGE_PREFIX}class-coverage.csv not found"
   fi

   exekutor sort -u "${COVERAGE_PREFIX}method-coverage.csv" | \
         strip_class_dependencies_from_methods | \
         redirect_exekutor "${OPTIMIZE_DIR}/method-coverage.csv" optionally_strip_class_load_from_methods
   redirect_exekutor "${OPTIMIZE_DIR}/class-coverage.csv" sort -u "${COVERAGE_PREFIX}class-coverage.csv"
}


optimize_folder()
{
   log_entry "optimize_folder" "$@"

   local folder="$1"

   local opti
   local directoryname
   local name

   directoryname="`fast_basename "${folder}"`"
   name="`basename -- "${directoryname}" ".d"`"
   opti="${OPTIMIZE_DIR}/${directoryname}"

   mkdir -p "${opti}" || fail "failed to create \"${opti}\""

   log_fluff "Optimize \"${folder}\" in \"${opti}\""

   #
   # collect all object files
   # if this directory can be optimized, then there are no loaders present
   # if this directory is c-only, we take everything anyway
   # if this directory can not be optimized, there may be loaders though
   # which will be taken care of later
   #
   redirect_exekutor "${opti}/all_files" ls -1 "${folder}/"*.o

   [ ! -f "${folder}/.unpack_done" ] && \
      fail "\"${folder}\" was unpacked incompletely by mulle-objc-unarchive"

   if [ -f "${folder}/.c_only" ]
   then
      log_verbose "${C_MAGENTA}${C_BOLD}${name}${C_VERBOSE} is C"

      exekutor tr '\010' '\000' < "${opti}/all_files" | \
               exekutor xargs ar -q -c -S "${C_LIBRARY}" || \
                  fail "Could not add to \"${C_LIBRARY}\""
      return 0
   fi

   #
   # in the non-optimizable case, just add all .o files
   # make sure that loaders are last
   #
   local unoptimizable

   if [ -f "${folder}/.unoptimizable" ]
   then
      unoptimizable="YES"

      log_verbose "${C_MAGENTA}${C_BOLD}${name}${C_VERBOSE} is unoptimizable ObjC"

      redirect_exekutor "${opti}/objc_files" \
         fgrep -v "${folder}/MulleObjCLoader" "${opti}/all_files"
      redirect_append_exekutor "${opti}/objc_files" \
          ls -1 "${folder}/MulleObjCLoader"*.o 2> /dev/null
   else
      unoptimizable="NO"

      [ ! -f "${folder}/.unarchive_done" ] && \
         fail "\"${folder}\" was unarchived incompletely by mulle-objc-unarchive"

      [ ! -f "${folder}/method_db.csv" ] && internal_fail "\"${folder}/method_db.csv\" is missing"
      [ ! -f "${folder}/class_db.csv" ] && internal_fail "\"${folder}/class_db.csv\" is missing"
      [ ! -f "${OPTIMIZE_DIR}/method-coverage.csv" ] && internal_fail "\"${OPTIMIZE_DIR}/method-coverage.csv\" is missing"
      [ ! -f "${OPTIMIZE_DIR}/class-coverage.csv" ] && internal_fail "\"${OPTIMIZE_DIR}/class-coverage.csv\" is missing"

      log_verbose "${C_MAGENTA}${C_BOLD}${name}${C_VERBOSE} is ObjC"

      #
      # get actually used methods in classes from coverage
      # coverage has been cleaned off +dependencies
      #
      redirect_exekutor "${opti}/used_method_db.csv" \
         fgrep -f "${OPTIMIZE_DIR}/method-coverage.csv" "${folder}/method_db.csv"

      redirect_exekutor "${opti}/used_class_db.csv" \
         fgrep -f "${OPTIMIZE_DIR}/class-coverage.csv" "${folder}/class_db.csv"

      # collect object files containing used methods and classes
      (
         exekutor awk -F ';' '{ print $7 }' "${opti}/used_method_db.csv"
         exekutor awk -F ';' '{ print $5 }' "${opti}/used_class_db.csv"
      ) | redirect_exekutor "${opti}/objc_files" sort -u

      #
      # figure out remaining files
      # fgrep doesn't match empty files well though
      #
      if [ ! -z "`head -1 "${opti}/objc_files"`" ]
      then
         redirect_exekutor "${opti}/c_files" \
             fgrep -v -f "${opti}/objc_files" "${opti}/all_files"
      else
         exekutor cp "${opti}/all_files" "${opti}/c_files"
      fi

      local optimized
      local all

      optimized="`exekutor wc -l "${opti}/c_files" | awk '{ print $1}'`"
      all="`exekutor wc -l "${opti}/all_files" | awk '{ print $1}'`"
      log_verbose "${optimized} of ${all} files were optimized"
   fi

   local has_objects
   #
   # add files to the libraries already
   # doesn't work with spaces in filenames though...
   #
   has_objects="`exekutor head -1 "${opti}/objc_files"`"
   if [ ! -z "${has_objects}" ]
   then
      log_fluff "Adding unoptimizable files of \"${name}\" to \"${OBJC_LIBRARY}\"..."
      exekutor tr '\010' '\000' < "${opti}/objc_files" | \
               exekutor xargs ar -q -c -S "${OBJC_LIBRARY}" || \
                  fail "Could not add to \"${OBJC_LIBRARY}\""
   fi

   #
   # if library is unoptimizable we are done now
   #
   if [ "${unoptimizable}" = "YES" ]
   then
      log_fluff "As \"${name}\" is unoptimizable, we are done here"
      return 0
   fi

   has_objects="`exekutor head -2 "${opti}/c_files" 2> /dev/null`"
   if [ ! -z "${has_objects}" ]
   then
      log_fluff "Adding optimizable files of \"${name}\" to \"${C_LIBRARY}\"..."
      exekutor tr '\010' '\000' < "${opti}/c_files" | \
               exekutor xargs ar -q -c -S "${C_LIBRARY}" || \
                  fail "Could not add to \"${C_LIBRARY}\""
   fi

   #
   # now re-build the loader for non optimizable
   # use ${opti}/used_method_db.csv and "${opti}/used_class_db.csv"
   #
   loadername="MulleObjCLoader+${name}"
   srcfile="${folder}/${loadername}.m"
   ofile="${opti}/${loadername}.m.o"  # cmake compatible

   log_fluff "Rebuilding the loader \"${ofile}\"..."

   redirect_exekutor "${opti}/class-objc-loader.inc" sed 's/^\([^;]*\);\([^;]*\);.*$/      { @selector( \2), MULLE_OBJC_NO_CATEGORYID },      \/\/ \1;\2;;/' \
      "${opti}/used_class_db.csv"

   redirect_exekutor "${opti}/category-objc-loader.inc" sed 's/^\([^;]*\);\([^;]*\);\([^;]*\);\([^;]*\);.*$/      { @selector( \2), @selector( \4) },      \/\/ \1;\2;\3;\4/' \
      "${opti}/used_method_db.csv"

   exekutor [ ! -f "${srcfile}" ] && internal_fail "\"${srcfile}\" is missing"

   eval_exekutor mulle-clang -c -o "'${ofile}'" "${CPPFLAGS}" "${CFLAGS}" -I"'${opti}'" "'${srcfile}'" || fail "Failed to recompile the loader"

   log_fluff "Add \"${name}\" 's loader to \"${OBJC_LIBRARY}\"..."

   exekutor ar -q -c -S "${OBJC_LIBRARY}" "${ofile}" || fail "Could not add to \"${OBJC_LIBRARY}\""

   return 0
}


optimize()
{
   log_debug "optimize" "$*"

   local folder
   local anything

   prepare_coverage_files || return 1

   if [ $# -eq 0 ]
   then
      anything="NO"
      IFS="
"
      for folder in `ls -1d ${UNARCHIVE_PREFIX}*.d 2> /dev/null`
      do
         IFS="${DEFAULT_IFS}"

         anything="YES"
         if [ ! -f "${i}/.unpack_done" ]
         then
            log_warning "Ignoring stray folder \"${folder}\""
            continue
         fi

         optimize_folder "${folder}"
      done
      IFS="${DEFAULT_IFS}"
   else
      while [ $# -ne 0 ]
      do
         folder="`foldername_from_library "$1" "${UNARCHIVE_PREFIX}"`"

         optimize_folder "${folder}"
         shift
      done
   fi

   if [ "${anything}" = "NO" ]
   then
      if [ -z "${UNARCHIVE_PREFIX}" ]
      then
         fail "There was nothing found to optimize!"
      else
         fail "There was nothing found to optimize in \"${UNARCHIVE_PREFIX}\""
      fi
   fi

   if [ -f "${OBJC_LIBRARY}" ]
   then
      exekutor ranlib "${OBJC_LIBRARY}"
      log_verbose "Produced \"${OBJC_LIBRARY}\" for Objective-C link (-all_load)"
   else
      log_warning "All Objective-C code optimized away. That's probably not good!!"
      create_empty_library "${OBJC_LIBRARY}" "objc"
   fi

   if [ -f "${C_LIBRARY}" ]
   then
      exekutor ranlib "${C_LIBRARY}"
      log_verbose "Produced \"${C_LIBRARY}\" for standard link"
   else
      log_info "No optimizable Objective-C code found!"
      create_empty_library "${C_LIBRARY}" "c"
   fi
}


main()
{
   local OPTION_CLEANUP_TMP="" # empty

   local OBJC_LIBRARY
   local C_LIBRARY
   local C_NAME
   local OBJC_NAME
   local CLEANUP
   local C_DEFAULT_NAME
   local OBJC_DEFAULT_NAME

   C_DEFAULT_NAME="`lib_pretension`_c`lib_extension`"
   OBJC_DEFAULT_NAME="`lib_pretension`_ObjC.`lib_extension`"

   if [ -z "${MULLE_VIRTUAL_ROOT}" ]
   then
      MULLE_VIRTUAL_ROOT="`mulle-sde project-dir`"
      [ -z "${MULLE_VIRTUAL_ROOT}" ] && fail "MULLE_VIRTUAL_ROOT can not be determined"
   fi

   DEPENDENCY_DIR="${DEPENDENCY_DIR:-${MULLE_CRAFT_DEPENDENCY_DIR}}"
   DEPENDENCY_DIR="${DEPENDENCY_DIR:-${MULLE_VIRTUAL_ROOT}/${MULLE_CRAFT_DEPENDENCY_DIRNAME:-dependency}}"

   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      # your option handling
      case "$1" in
         --version)
            echo "${MULLE_EXECUTABLE_VERSION}"
            exit 0
         ;;

         --keep-tmp)
            OPTION_CLEANUP_TMP="NO"
         ;;

         --c-name)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            C_NAME="$1"
         ;;

         --objc-name)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            OBJC_NAME="$1"
         ;;

         --cppflags)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            CPPFLAGS="$1"
         ;;

         --cflags)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            CFLAGS="$1"
         ;;

         --dependency-dir|--dependencies-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            DEPENDENCY_DIR="$1"
         ;;

         --coverage-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            COVERAGE_PREFIX="$1"
            case "${COVERAGE_PREFIX}" in
               */|"")
               ;;

               *)
                  COVERAGE_PREFIX="${COVERAGE_PREFIX}/"
               ;;
            esac
         ;;

         --unarchive-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            UNARCHIVE_PREFIX="$1"
            case "${UNARCHIVE_PREFIX}" in
               */|"")
               ;;

               *)
                  UNARCHIVE_PREFIX="${UNARCHIVE_PREFIX}/"
               ;;
            esac
         ;;

         --library-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            LIB_PREFIX="$1"
            case "${LIB_PREFIX}" in
               */|"")
               ;;

               *)
                  LIB_PREFIX="${LIB_PREFIX}/"
               ;;
            esac
         ;;

         --optimize-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            OPTIMIZE_DIR="$1"
            CLEANUP="NO"
         ;;

         --tmp-dir)
            [ $# -eq 1 ] && fail "missing argument to $1"
            shift

            TMPDIR="$1"  # "OS" variable for mktemp
            mkdir_if_missing "${TMPDIR}" || fail "Could not create \"${TMPDIR}\""
         ;;

         --strip-loads)
            OPTION_STRIP_LOAD="YES"
         ;;

         -h|--help)
            usage
         ;;

         -*)
            fail "unknown option $1"
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE}"

   if [ -z "${DEPENDENCY_DIR}" ]
   then
      fail "DEPENDENCY_DIR is not defined"
   fi


   if [ -z "${CC}" ]
   then
      case "${MULLE_UNAME}" in
         mingw*)
            CC="mulle-clang-cl"
         ;;

         *)
            CC="mulle-clang"
         ;;
      esac
   fi

   if [ -z "${CPPFLAGS}" ]
   then
      case "${MULLE_UNAME}" in
         darwin)
            CPPFLAGS="-isysroot "'`xcrun --show-sdk-path`'""
         ;;
      esac

      CPPFLAGS="`concat "${CPPFLAGS}" "-isystem '${DEPENDENCY_DIR}/include'" `"
   fi

   OBJC_LIBRARY="${LIB_PREFIX}${OBJC_NAME:-${OBJC_DEFAULT_NAME}}"
   C_LIBRARY="${LIB_PREFIX}${C_NAME:-${C_DEFAULT_NAME}}"

   remove_file_if_present "${OBJC_LIBRARY}" || return 1
   remove_file_if_present "${C_LIBRARY}" || return 1

   if [ -z "${OPTIMIZE_DIR}" ]
   then
      OPTIMIZE_DIR="`make_tmp_directory "optimize"`"
      log_fluff "OPTIMIZE_DIR is ${OPTIMIZE_DIR}"
      CLEANUP="${OPTION_CLEANUP_TMP:-YES}"
   fi

   mkdir_if_missing "${OPTIMIZE_DIR}"

   optimize "$@" || return 1

   if [ "${CLEANUP}" = "YES" ]
   then
      exekutor rm -rf "${OPTIMIZE_DIR}"
   fi
}


_init()
{
   if [ -z "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}" ]
   then
      MULLE_BASHFUNCTIONS_LIBEXEC_DIR="`mulle-bashfunctions-env "libexec-dir" 2> /dev/null`"
      [ -z "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}" ] && \
         echo "mulle-bashfunctions-env not installed" >&2 && \
         exit 1
   fi

   . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-bashfunctions.sh" || exit 1

   set -o pipefail
}

#
# leading backslash ? looks like we're getting called from
# mingw via a .BAT or so
#
case "$PATH" in
   '\\'*)
      PATH="`tr '\\' '/' <<< "${PATH}"`"
   ;;
esac

#
# combine all coverage files into one and sort -u it
#

_init "$@"
main "$@"
