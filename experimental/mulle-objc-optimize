#! /bin/sh
#
# this script accepts a file of coverage info
# each line is matches against the .csv output from
# mulle-objc-unarchive, the corresponding .o file
# is then printed-
#
# You then get a library obcj.a, that is linked wholesale
# and a library c.a that is linked normally, so that the
# linker only cherrypicks required symbols.
#

_collect_objc_o_files()
{
   local line

   # cut first two fields from coverage info

   cut -d';' -f3-8 | while read line
   do
      case "${line}" in
         "#"*|"")
            continue
         ;;
      esac

      if ! fgrep -s -m 1 "${line}" method_db.csv
      then
         # class/methods defined in the executable presumably
         echo "No match was found for ${line}." >&2
         continue
      fi

   done
}


collect_objc_o_files()
{
   local collect

   collect="`_collect_objc_o_files`" || exit 1
   echo "${collect}" | cut -d';' -f7 | sort -u || exit 1
}


collect_c_o_files()
{
   local objc_filenames="$1"

   for ofilename in *.d/*.o
   do
      if fgrep -q -s -x "${ofilename}" <<< "${objc_filenames}"
      then
         continue
      fi

      echo "${ofilename}"
   done
}


main()
{
   local objc_filenames
   local c_filenames

   if [ -f "objc.a" ]
   then
      rm objc.a || exit 1
   fi
   if [ -f "c.a" ]
   then
      rm c.a || exit 1
   fi

   objc_filenames="`collect_objc_o_files`" || exit 1
   echo "${objc_filenames}" | sed 's|\(.*\)|Used ObjC .o \1|' >&2

   ar -q objc.a ${objc_filenames}
   ranlib objc.a

   c_filenames="`collect_c_o_files "${objc_filenames}"`" || exit 1
   ar -q c.a ${c_filenames}
   ranlib c.a
}

#
# combine all coverage files into one and sort -u it
#
main "$@"


#
# Problems with this:
#
# a) does not catch superclasses, that would be required for loading
#    the classes. This can be easily fixed.
#
# b) Ignores +loads since they are not cached
#
# c) MulleObjCLoader categories and +dependencies are ignored, which
#    could lead to stalls when loading stuff.
